# [백준]1904번-동적계획법-01타일-S3
# https://github.com/irishNoah/Algorithm-Study
# https://www.acmicpc.net/problem/1904

'''
00인 타일을 'X'로, 1인 타일을 'Y'로 치환해서
N이 1~6일 때의 경우의 수를 각각 구하다보면
N이 증가할 때마다 발생할 수 있는 경우의 수가 피보나치 수열을
형성한다는 것을 파악할 수 있다.
'''

def tile(n):
    if n == 1:
        return tableFib[1]
    
    for cnt in range(2, n+1):
        tableFib[cnt] = (tableFib[cnt-2] + tableFib[cnt-1]) % 15746

    return tableFib[n]


n = int(input())

# DP 활용 위한 리스트 테이블 생성
tableFib = [0] * 1000001 
tableFib[0] = 1; tableFib[1] = 1

print(tile(n))

'''
- 처음에는 마지막 print문에서 tile() 함수를 통해 얻어온 값에서 
15746로 나눈 나머지 값을 출력하게 했다. 하지만, 이렇게 제출한 것에서
메모리 초과 판정을 얻게 됐다.
- dp로 피보나치와 같은 경우를 풀게 될 경우, 재귀 함수에 비해 시간을 비약적으로
줄일 수 있다는 것은 확실히 알 수 있다.
- 하지만, 리스트 자체의 각각의 값은 n이 값이 클 수록 각 피보나치 n에 대한 결과값은 매우 커지게 된다.
- 이 문제에서의 n의 최대값은 1,000,000이다. 즉, 1,000,000을 입력하게 되면, 이에 대한 값은 매우 커지게 될 것이다.
- 그렇기 때문에, 이 문제에서 메모리 초과 판정을 받게 된 것이다.
- 그렇다면, 어떻게 해결할 수 있을까?
- 그 방법은 마지막 print문에서 나머지 값을 구하는 것이 아니라,
애초에 각 리스트 값에서 나머지로 나눈 값을 구하는 것이다.
이렇게 할 경우 각 리스트의 값이 매우 작은 수가 될 것이기 때문이다!
'''